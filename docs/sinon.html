
<!DOCTYPE html>


<html><head><meta charset="utf-8" /><title>Sinon.JS - Documentation</title><link href="/a1fe67e2ef34/styles/sinon.css" rel="stylesheet" type="text/css" /></head><body><div class="payoff"><h1><a href="/">Sinon.JS</a></h1><p>Standalone test spies, stubs and mocks for JavaScript.<br />
          No dependencies, works with any unit testing framework.</p></div><ul class="nav main-nav"><li><strong>Documentation</strong></li><li><a href="#spies">Spies</a></li><li><a href="#stubs">Stubs</a></li><li><a href="#mocks">Mocks</a></li><li><a href="#clock">Fake timers</a></li><li><a href="#server">Fake <code>XHR</code> and server</a></li><li><a href="#json-p">JSON-P</a></li><li><a href="#assertions">Assertions</a></li><li><a href="#matchers">Matchers</a></li><li><a href="#sandbox">Sandboxing</a></li><li><a href="#utils">Utils</a></li></ul><div class="docs"><p>This page contains the entire Sinon.JS API documentation along with brief
    introductions to the concepts Sinon implements. Please ask questions on
    <a href="http://groups.google.com/group/sinonjs">the mailing list</a> if
    you're stuck. I also really appreciate suggestions to improve the
    documentation so Sinon.JS is easier to work with. Get in touch!</p><div class="section" id="spies"><h2>Test spies <a class="api" href="#spies-api">API reference</a></h2><ul class="nav">
  <li><a href="#sinonspy">sinon.spy()</a></li>
  <li><a href="#spies-api">spy API</a></li>
  <li><a href="#spycall">spy call API</a></li>
</ul><h3>What is a test spy?</h3><p>A test spy is a function that records arguments, return value, the value of <code>this</code> and exception thrown (if any) for all its calls. A test spy can be an anonymous function or it can wrap an existing function.</p><h3>When to use spies?</h3><p>Test spies are useful to test both callbacks and how certain functions/methods are used throughout the system under test. The following simplified example shows how to use spies to test how a function handles a callback:</p>
<pre class="codehilite javascript"><code><span class="s2">"test should call subscribers on publish"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s2">"message"</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">publishSync</span><span class="p">(</span><span class="s2">"message"</span><span class="p">);</span>

    <span class="nx">assertTrue</span><span class="p">(</span><span class="nx">callback</span><span class="p">.</span><span class="nx">called</span><span class="p">);</span>
<span class="p">}</span>
</code></pre><h3>Spying on existing methods</h3><p><code>sinon.spy</code> can also spy on existing functions. When doing so, the original function will behave just as normal (including when used as a constructor) but you will have access to data about all calls. The following is a slightly contrived example:</p>
<pre class="codehilite javascript"><code><span class="p">{</span>
    <span class="nx">setUp</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">,</span> <span class="s2">"ajax"</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="nx">tearDown</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">.</span><span class="nx">restore</span><span class="p">();</span> <span class="c1">// Unwraps the spy</span>
    <span class="p">},</span>

    <span class="s2">"test should inspect jQuery.getJSON's usage of jQuery.ajax"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">jQuery</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s2">"/some/resource"</span><span class="p">);</span>

        <span class="nx">assert</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">.</span><span class="nx">calledOnce</span><span class="p">);</span>
        <span class="nx">assertEquals</span><span class="p">(</span><span class="s2">"/some/resource"</span><span class="p">,</span> <span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">.</span><span class="nx">getCall</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">url</span><span class="p">);</span>
        <span class="nx">assertEquals</span><span class="p">(</span><span class="s2">"json"</span><span class="p">,</span> <span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">.</span><span class="nx">getCall</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">dataType</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre><h3>Creating spies: <code>sinon.spy()</code></h3><p><a name="sinonspy"></a></p>
<dl>
  <dt><code>var spy = sinon.spy();</code></dt>
  <dd>
    Creates an anonymous function that records arguments, <code>this</code> value,
    exceptions and return values for all calls.
  </dd>
  <dt><code>var spy = sinon.spy(myFunc);</code></dt>
  <dd>Spies on the provided function</dd>
  <dt><code>var spy = sinon.spy(object, "method");</code></dt>
  <dd>
    Creates a <a href="#spyprops">spy</a> for <code>object.method</code> and
    replaces the original method with the spy. The spy acts exactly like the
    original method in all cases. The original method can be restored by calling
    <code>object.method.restore()</code>. The returned spy is the function
    object which replaced the original method. <code>spy === object.method</code>.
  </dd>
</dl><h3>Spy API</h3><p><a name="spyprops"></a></p><p>Spies provide a rich interface to inspect their usage. The above examples showed the <code>calledOnce</code> boolean property as well as the <code>getCall</code> method and the returned object’s <code>args</code> property. There are three ways of inspecting call data.</p><p>The preferred approach is to use the spy’s <code>calledWith</code> method (and friends) because it keeps your test from being too specific about which call did what and so on. It will return <code>true</code> if the spy was ever called with the provided arguments.</p>
<pre class="codehilite javascript"><code><span class="s2">"test should call subscribers with message as first argument"</span> <span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s1">'an example message'</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">spy</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">publishSync</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="s2">"some payload"</span><span class="p">);</span>

    <span class="nx">assert</span><span class="p">(</span><span class="nx">spy</span><span class="p">.</span><span class="nx">calledWith</span><span class="p">(</span><span class="nx">message</span><span class="p">));</span>
<span class="p">}</span>
</code></pre><p>If you want to be specific, you can directly check the first argument of the first call. There are two ways of achieving this:</p>
<pre class="codehilite javascript"><code><span class="s2">"test should call subscribers with message as first argument"</span> <span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s1">'an example message'</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">spy</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">publishSync</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="s2">"some payload"</span><span class="p">);</span>

    <span class="nx">assertEquals</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">spy</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre>
<pre class="codehilite javascript"><code><span class="s2">"test should call subscribers with message as first argument"</span> <span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s1">'an example message'</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">spy</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">publishSync</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="s2">"some payload"</span><span class="p">);</span>

    <span class="nx">assertEquals</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">spy</span><span class="p">.</span><span class="nx">getCall</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre><p>The first example uses the two-dimensional <code>args</code> array directly on the spy, while the second example fetches the first call object and then accesses it’s <code>args</code> array. Which one to use is a matter of preference, but the recommended approach is going with <code>spy.calledWith(arg1, arg2, ...)</code> unless there’s a need to make the tests highly specific.</p><h3>Spy API</h3><a name="spies-api"></a><p>Spy objects are objects returned from `sinon.spy()`. When spying on existing
methods with `sinon.spy(object, method)`, the following properties and methods
are also available on `object.method`.</p><dl class="dafuq"><dt><code>spy.withArgs(arg1[, arg2, ...]);</code></dt><dd><p>Creates a spy that only records calls when  the received arguments match those passed to <code>withArgs</code>. This is useful to  be more expressive in your assertions, where you can access the spy with the  same call.</p><pre class="codehilite javascript"><code><span class="s2">"should call method once with each argument"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{}</span> <span class="p">};</span>
    <span class="kd">var</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="s2">"method"</span><span class="p">);</span>
    <span class="nx">spy</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="nx">spy</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="nx">object</span><span class="p">.</span><span class="nx">method</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="nx">object</span><span class="p">.</span><span class="nx">method</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="nx">assert</span><span class="p">(</span><span class="nx">spy</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="mi">42</span><span class="p">).</span><span class="nx">calledOnce</span><span class="p">);</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">spy</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">calledOnce</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></dd><dt><code>spy.callCount</code></dt><dd><p>The number of recorded calls.</p></dd><dt><code>spy.called</code></dt><dd><p><code>true</code> if the spy was called at least once</p></dd><dt><code>spy.calledOnce</code></dt><dd><p><code>true</code> if spy was called exactly once</p></dd><dt><code>spy.calledTwice</code></dt><dd><p><code>true</code> if the spy was called exactly twice</p></dd><dt><code>spy.calledThrice</code></dt><dd><p><code>true</code> if the spy was called exactly thrice</p></dd><dt><code>spy.firstCall</code></dt><dd><p>The first call</p></dd><dt><code>spy.secondCall</code></dt><dd><p>The second call</p></dd><dt><code>spy.thirdCall</code></dt><dd><p>The third call</p></dd><dt><code>spy.lastCall</code></dt><dd><p>The last call</p></dd><dt><code>spy.calledBefore(anotherSpy);</code></dt><dd><p>Returns <code>true</code> if the spy was called before <code>anotherSpy</code></p></dd><dt><code>spy.calledAfter(anotherSpy);</code></dt><dd><p>Returns <code>true</code> if the spy was called after <code>anotherSpy</code></p></dd><dt><code>spy.calledOn(obj);</code></dt><dd><p>Returns <code>true</code> if the spy was called at least once with <code>obj</code> as <code>this</code>.</p></dd><dt><code>spy.alwaysCalledOn(obj);</code></dt><dd><p>Returns <code>true</code> if the spy was always called with <code>obj</code> as <code>this</code>.</p></dd><dt><code>spy.calledWith(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if spy was called at least once with the provided  arguments. Can be used for partial matching, Sinon only checks the provided  arguments against actual arguments, so a call that received the provided arguments  (in the same spots) and possibly others as well will return <code>true</code>.</p></dd><dt><code>spy.alwaysCalledWith(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if spy was always called with the provided arguments (and possibly others).</p></dd><dt><code>spy.calledWithExactly(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if spy was called at least once with the provided arguments and no others.</p></dd><dt><code>spy.alwaysCalledWithExactly(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if spy was always called with the exact provided arguments.</p></dd><dt><code>spy.calledWithMatch(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if spy was called with matching arguments  (and possibly others). This behaves the same as  <code>spy.calledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd><dt><code>spy.alwaysCalledWithMatch(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if spy was always called with matching arguments  (and possibly others). This behaves the same as  <code>spy.alwaysCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd><dt><code>spy.calledWithNew();</code></dt><dd><p>Returns <code>true</code> if spy/stub was called the <code>new</code>  operator. Beware that this is inferred based on the value of  the <code>this</code> object and the spy  function’s <code>prototype</code>, so it may give false positives if  you actively return the right kind of object.</p></dd><dt><code>spy.neverCalledWith(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if the spy/stub was never called with the provided arguments.</p></dd><dt><code>spy.neverCalledWithMatch(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if the spy/stub was never called with  matching arguments. This behaves the same as  <code>spy.neverCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd><dt><code>spy.threw();</code></dt><dd><p>Returns <code>true</code> if spy threw an exception at least once.</p></dd><dt><code>spy.threw("TypeError");</code></dt><dd><p>Returns <code>true</code> if spy threw an exception of the provided type at least once.</p></dd><dt><code>spy.threw(obj);</code></dt><dd><p>Returns <code>true</code> if spy threw the provided exception object at least once.</p></dd><dt><code>spy.alwaysThrew();</code></dt><dd><p>Returns <code>true</code> if spy always threw an exception.</p></dd><dt><code>spy.alwaysThrew("TypeError");</code></dt><dd><p>Returns <code>true</code> if spy always threw an exception of the provided type.</p></dd><dt><code>spy.alwaysThrew(obj);</code></dt><dd><p>Returns <code>true</code> if spy always threw the provided exception object.</p></dd><dt><code>spy.returned(obj);</code></dt><dd><p>Returns <code>true</code> if spy returned the provided value at least once.  Uses deep comparison for objects and arrays.  Use <code>spy.returned(sinon.match.same(obj))</code> for strict  comparison (see <a href="#matchers">matchers</a>).</p></dd><dt><code>spy.alwaysReturned(obj);</code></dt><dd><p>Returns <code>true</code> if spy always returned the provided value.</p></dd><dt><code>var spyCall = spy.getCall(n);</code></dt><dd><p>
      Returns the <em>nth</em> [call](#spycall). Accessing individual calls
      helps with more detailed behavior verification when the spy is called more
      than once. Example:
    </p><pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">,</span> <span class="s2">"ajax"</span><span class="p">);</span>
<span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">(</span><span class="s2">"/stuffs"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">spyCall</span> <span class="o">=</span> <span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">.</span><span class="nx">getCall</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="nx">assertEquals</span><span class="p">(</span><span class="s2">"/stuffs"</span><span class="p">,</span> <span class="nx">spyCall</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></dd><dt><code>spy.thisValues</code></dt><dd><p>Array of <code>this</code> objects, <code>spy.thisValues[0]</code> is the <code>this</code>  object for the first call.</p></dd><dt><code>spy.args</code></dt><dd><p>Array of arguments received, <code>spy.args[0]</code> is an array of  arguments received in the first call.</p></dd><dt><code>spy.exceptions</code></dt><dd><p>Array of exception objects thrown, <code>spy.exceptions[0]</code> is  the exception thrown by the first call. If the call did not throw an  error, the value at the call’s location in <code>.exceptions</code>  will be ‘undefined’.</p></dd><dt><code>spy.returnValues</code></dt><dd><p>Array of return values, <code>spy.returnValues[0]</code> is the return  value of the first call. If the call did not explicitly return a  value, the value at the call’s location in <code>.returnValues</code>  will be ‘undefined’.</p></dd><dt><code>spy.reset()</code></dt><dd><p>Resets the state of a spy.</p></dd><dt><code>spy.printf(format string", [arg1, arg2, ...])`</code></dt><dd><p>Returns the passed format string with the following replacements performed:  </p><ul>  <li><code>%n</code>: the name of the spy (“spy” by default)</li>  <li><code>%c</code>: the number of times the spy was called, in words (“once”, “twice”, etc.)</li>  <li><code>%C</code>: a list of string representations of the calls to the spy, with each call prefixed by a newline and four spaces</li>  <li><code>%t</code>: a comma-delimited list of <code>this</code> values the spy was called on</li>  <li><code>%&lt;var&gt;n&lt;/var&gt;</code>: the formatted value of the <var>n</var>th argument passed to <code>printf</code></li>  <li><code>%*</code>: a comma-delimited list of the (non-format string) arguments passed to <code>printf</code></li>  </ul></dd></dl><h3>Individual spy calls</h3><a name="spycall"></a><p></p><dl class="dafuq"><dt><code>var spyCall = spy.getCall(n)</code></dt><dd><p>
      Returns the <em>nth</em> [call](#spycall). Accessing individual calls
      helps with more detailed behavior verification when the spy is called more
      than once. Example:
    </p><pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">,</span> <span class="s2">"ajax"</span><span class="p">);</span>
<span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">(</span><span class="s2">"/stuffs"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">spyCall</span> <span class="o">=</span> <span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">.</span><span class="nx">getCall</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="nx">assertEquals</span><span class="p">(</span><span class="s2">"/stuffs"</span><span class="p">,</span> <span class="nx">spyCall</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></dd><dt><code>spyCall.calledOn(obj);</code></dt><dd><p>Returns <code>true</code> if <code>obj</code> was <code>this</code> for this call.</p></dd><dt><code>spyCall.calledWith(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if call received provided arguments (and possibly others).</p></dd><dt><code>spyCall.calledWithExactly(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if call received provided arguments and no others.</p></dd><dt><code>spyCall.calledWithMatch(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if call received matching arguments (and possibly others). This behaves the same as <code>spyCall.calledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd><dt><code>spyCall.notCalledWith(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if call did not receive provided arguments.</p></dd><dt><code>spyCall.notCalledWithMatch(arg1, arg2, ...);</code></dt><dd><p>Returns <code>true</code> if call did not receive matching arguments. This behaves the same as <code>spyCall.notCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd><dt><code>spyCall.threw();</code></dt><dd><p>Returns <code>true</code> if call threw an exception.</p></dd><dt><code>spyCall.threw(TypeError");`</code></dt><dd><p>Returns <code>true</code> if call threw exception of provided type.</p></dd><dt><code>spyCall.threw(obj);</code></dt><dd><p>Returns <code>true</code> if call threw provided exception object.</p></dd><dt><code>spyCall.thisValue</code></dt><dd><p>The call’s <code>this</code> value.</p></dd><dt><code>spyCall.args</code></dt><dd><p>Array of received arguments.</p></dd><dt><code>spyCall.exception</code></dt><dd><p>Exception thrown, if any.</p></dd><dt><code>spyCall.returnValue</code></dt><dd><p>Return value.</p></dd></dl></div><div class="section" id="stubs"><h2>Test stubs <a class="api" href="#stubs-api">API reference</a></h2><h3>What are stubs?</h3><p>Test stubs are functions (spies) with pre-programmed behavior. They support the full <a href="#spies">test spy API</a> in addition to methods which can be used to alter the stub’s behavior.</p><p>As spies, stubs can be either anonymous, or wrap existing functions. When wrapping an existing function with a stub, the original function is not called.</p><h3>When to use stubs?</h3><p>Use a stub when you want to:</p>
<ol>
  <li><p>Control a method’s behavior from a test to force the code down a specific  path. Examples include forcing a method to throw an error in order to test  error handling.</p></li>
  <li><p>When you want to prevent a specific method from being called directly  (possibly because it triggers undesired behavior, such as a XMLHttpRequest or  similar).</p></li>
</ol><p>The following example is yet another test from Morgan Roderick’s PubSubJS which shows how to create an anonymous stub that throws an exception when called.</p>
<pre class="codehilite javascript"><code><span class="s2">"test should call all subscribers, even if there are exceptions"</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s1">'an example message'</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">error</span> <span class="o">=</span> <span class="s1">'an example error message'</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">stub</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">().</span><span class="kr">throws</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">spy1</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">spy2</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">stub</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">spy1</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">spy2</span><span class="p">);</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">publishSync</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">);</span>

    <span class="nx">assert</span><span class="p">(</span><span class="nx">spy1</span><span class="p">.</span><span class="nx">called</span><span class="p">);</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">spy2</span><span class="p">.</span><span class="nx">called</span><span class="p">);</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">stub</span><span class="p">.</span><span class="nx">calledBefore</span><span class="p">(</span><span class="nx">spy1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre><p>Note how the stub also implements the spy interface. The test verifies that all callbacks where called, and also that the exception throwing stub was called before one of the other callbacks.</p><h3>Defining stub behavior on consecutive calls</h3><p>Calling behavior defining methods like <code>returns</code> or <code>throws</code> multiple times overrides the behavior of the stub. As of Sinon version 1.8, you can use the <a href="" stub-oncall="stub-oncall"><code>onCall</code></a> method to make a stub respond differently on consecutive calls.</p><p>Note that in Sinon version 1.5 to version 1.7, multiple calls to the <code>yields*</code> and <code>callsArg*</code> family of methods define a sequence of behaviors for consecutive calls. As of 1.8, this functionality has been removed in favor of the <a href="#stub-onCall"><code>onCall</code></a> API.</p><h3>Stub API</h3><a name="spies-api"></a><p></p><dl class="dafuq"><dt><code>var stub = sinon.stub();</code></dt><dd><p>Creates an anonymous stub function.</p></dd><dt><code>var stub = sinon.stub(object, "method");</code></dt><dd><p>Replaces <code>object.method</code> with a stub function. The original  function can be restored by calling <code>object.method.restore();</code>  (or <code>stub.restore();</code>). An exception is thrown if the property  is not already a function, to help avoid typos when stubbing methods.</p></dd><dt><code>var stub = sinon.stub(object, "method", func);</code></dt><dd><p>Replaces <code>object.method</code> with a <code>func</code>, wrapped  in a <code>spy</code>. As usual, <code>object.method.restore();</code>  can be used to restore the original method.</p></dd><dt><code>var stub = sinon.stub(obj);</code></dt><dd><p>Stubs all the object’s methods. Note that it’s usually better  practice to stub individual methods, particularly on  objects that you don’t understand or control all the methods for  (e.g. library dependencies). Stubbing individual methods tests  intent more precisely and is less susceptible to unexpected  behavior as the object’s code evolves.<br />  If you want to create a stub object of <code>MyConstructor</code>,  but don’t want the constructor to be invoked, use this utility  function.</p><pre class="codehilite javascript"><code><span class="kd">var</span> <span class="nx">stub</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">createStubInstance</span><span class="p">(</span><span class="nx">MyConstructor</span><span class="p">)</span>
</code></pre></dd><dt><code>stub.withArgs(arg1[, arg2, ...]);</code></dt><dd><p>Stubs the method only for the provided arguments. This is useful to be  more expressive in your assertions, where you can access the spy with  the same call. It is also useful to create a stub that can act  differently in response to different arguments.</p><pre class="codehilite javascript"><code><span class="s2">"test should stub method differently based on arguments"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">();</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="mi">42</span><span class="p">).</span><span class="nx">returns</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="kr">throws</span><span class="p">(</span><span class="s2">"TypeError"</span><span class="p">);</span>

    <span class="nx">callback</span><span class="p">();</span> <span class="c1">// No return value, no exception</span>
    <span class="nx">callback</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// Returns 1</span>
    <span class="nx">callback</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Throws TypeError</span>
<span class="p">}</span>
</code></pre></dd><dt id="stub-onCall"><code>stub.onCall(n);</code></dt><dd><p><em>Added in Sinon.JS 1.8</em></p><p>Defines the behavior of the stub on the <em>nth</em> call. Useful for testing sequential interactions.</p><pre class="codehilite javascript"><code><span class="s2">"test should stub method differently on consecutive calls"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">();</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">onCall</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">returns</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">onCall</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">returns</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">returns</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="nx">callback</span><span class="p">();</span> <span class="c1">// Returns 1</span>
    <span class="nx">callback</span><span class="p">();</span> <span class="c1">// Returns 2</span>
    <span class="nx">callback</span><span class="p">();</span> <span class="c1">// All following calls return 3</span>
<span class="p">}</span>
</code></pre><p>There are methods <code>onFirstCall</code>, <code>onSecondCall</code>,<code>onThirdCall</code> to make stub definitions read more naturally.</p>
<pre><code>                      `onCall` can be combined with all of the behavior defining methods in this section.  In particular, it can be used together with `withArgs`.
</code></pre><pre class="codehilite javascript"><code><span class="s2">"test should stub method differently on consecutive calls with certain argument"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">();</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">onFirstCall</span><span class="p">().</span><span class="nx">returns</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">onSecondCall</span><span class="p">().</span><span class="nx">returns</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">returns</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="nx">callback</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Returns 0</span>
    <span class="nx">callback</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// Returns 1</span>
    <span class="nx">callback</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Returns 0</span>
    <span class="nx">callback</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// Returns 2</span>
    <span class="nx">callback</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Returns 0</span>
    <span class="nx">callback</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// Returns 0</span>
<span class="p">}</span>
</code></pre><p>Note how the behavior of the stub for argument <code>42</code> falls back to the default behavior once no more calls have been defined.</p></dd><dt><code>stub.onFirstCall();</code></dt><dd><p>Alias for <code>stub.onCall(0);</code></p></dd><dt><code>stub.onSecondCall();</code></dt><dd><p>Alias for <code>stub.onCall(1);</code></p></dd><dt><code>stub.onThirdCall();</code></dt><dd><p>Alias for <code>stub.onCall(2);</code></p></dd><dt><code>stub.returns(obj);</code></dt><dd><p>Makes the stub return the provided value.</p></dd><dt><code>stub.returnsArg(index);</code></dt><dd><p>Causes the stub to return the argument at the provided index.  <code>stub.returnsArg(0);</code> causes the stub to return the first argument.</p></dd><dt><code>stub.returnsThis();</code></dt><dd><p>Causes the stub to return its <code>this</code> value. Useful  for stubbing jQuery-style fluent APIs.</p></dd><dt><code>stub.throws();</code></dt><dd><p>Causes the stub to throw an exception (<code>Error</code>).</p></dd><dt><code>stub.throws("TypeError");</code></dt><dd><p>Causes the stub to throw an exception of the provided type.</p></dd><dt><code>stub.throws(obj);</code></dt><dd><p>Causes the stub to throw the provided exception object.</p></dd><dt><code>stub.callsArg(index);</code></dt><dd><p>Causes the stub to call the argument at the provided index as a callback  function. <code>stub.callsArg(0);</code> causes the stub to call the  first argument as a callback.</p></dd><dt><code>stub.callsArgOn(index, context);</code></dt><dd><p>Like above but with an additional parameter to pass the <code>this</code> context.</p></dd><dt><code>stub.callsArgWith(index, arg1, arg2, ...);</code></dt><dd><p>Like <code>callsArg</code>, but with arguments to pass to the callback.</p></dd><dt><code>stub.callsArgOnWith(index, context, arg1, arg2, ...);</code></dt><dd><p>Like above but with an additional parameter to pass the <code>this</code> context.</p></dd><dt><code>stub.yields([arg1, arg2, ...])</code></dt><dd><p>Almost like <code>callsArg</code>. Causes the stub to call the first  callback it receives with the provided arguments (if any). If a method  accepts more than one callback, you need to use <code>callsArg</code>  to have the stub invoke other callbacks than the first one.</p></dd><dt><code>stub.yieldsOn(context, [arg1, arg2, ...])</code></dt><dd><p>Like above but with an additional parameter to pass the <code>this</code> context.</p></dd><dt><code>stub.yieldsTo(property, [arg1, arg2, ...])</code></dt><dd><p>Causes the spy to invoke a callback passed as a property of an object  to the spy. Like <code>yields</code>, <code>yieldsTo</code> grabs the  first matching argument, finds the callback and calls it with the  (optional) arguments.</p></dd><dt><code>stub.yieldsToOn(property, context, [arg1, arg2, ...])</code></dt><dd><p>Like above but with an additional parameter to pass the <code>this</code> context.</p><pre class="codehilite javascript"><code><span class="s2">"test should fake successful ajax request"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">,</span> <span class="s2">"ajax"</span><span class="p">).</span><span class="nx">yieldsTo</span><span class="p">(</span><span class="s2">"success"</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>

    <span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
        <span class="nx">success</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assertEquals</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nx">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></dd><dt><code>spy.yield([arg1, arg2, ...])</code></dt><dd><p>Invoke callbacks passed to the <code>spy</code> with the given  arguments. If the spy was never called with a function argument,  <code>yield</code> throws an error. Also aliased as  <code>invokeCallback</code>.</p></dd><dt><code>spy.yieldTo(callback, [arg1, arg2, ...])</code></dt><dd><p>Invokes callbacks passed as a property of an object to the  spy. Like <code>yield</code>, <code>yieldTo</code> grabs the first  matching argument, finds the callback and calls it with the (optional)  arguments.</p><pre class="codehilite javascript"><code><span class="s2">"calling callbacks"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">();</span>
    <span class="nx">callback</span><span class="p">({</span>
        <span class="s2">"success"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Success!"</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="s2">"failure"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Oh noes!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="nx">callback</span><span class="p">.</span><span class="nx">yieldTo</span><span class="p">(</span><span class="s2">"failure"</span><span class="p">);</span> <span class="c1">// Logs "Oh noes!"</span>
<span class="p">}</span>
</code></pre></dd><dt><code>spy.callArg(argNum)</code></dt><dd><p>Like <code>yield</code>, but with an explicit argument number  specifying which callback to call. Useful if a function is called with  more than one callback, and simply calling the first callback is not  desired.</p><pre class="codehilite javascript"><code><span class="s2">"calling the last callback"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">();</span>
    <span class="nx">callback</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Success!"</span><span class="p">);</span>
    <span class="p">},</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Oh noes!"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">callback</span><span class="p">.</span><span class="nx">callArg</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Logs "Oh noes!"</span>
<span class="p">}</span>
</code></pre></dd><dt><code>spy.callArgWith(argNum, [arg1, arg2, ...])</code></dt><dd><pre><code>    Like `callArg`, but with arguments.
</code></pre></dd><dt><code>stub.callsArgAsync(index);</code></dt><dd><p>Same as their corresponding non-Async counterparts, but with callback being deferred (executed not immediately but after short timeout and in another “thread”)</p></dd><dt><code>stub.callsArgAsync(index);</code></dt><dd></dd><dt><code>stub.callsArgOnAsync(index, context);</code></dt><dd></dd><dt><code>stub.callsArgWithAsync(index, arg1, arg2, ...);</code></dt><dd></dd><dt><code>stub.callsArgOnWithAsync(index, context, arg1, arg2, ...);</code></dt><dd></dd><dt><code>stub.yieldsAsync([arg1, arg2, ...])</code></dt><dd></dd><dt><code>stub.yieldsOnAsync(context, [arg1, arg2, ...])</code></dt><dd></dd><dt><code>stub.yieldsToAsync(property, [arg1, arg2, ...])</code></dt><dd></dd><dt><code>stub.yieldsToOnAsync(property, context, [arg1, arg2, ...])</code></dt><dd><p>Same as their corresponding non-Async counterparts, but with callback being deferred (executed not immediately but after short timeout and in another “thread”)</p></dd></dl></div><div class="section" id="mocks"><h2>Mocks <a class="api" href="#mocks-api">API reference</a></h2><h3>What are mocks?</h3><p>Mocks (and mock expectations) are fake methods (like spies) with pre-programmed behavior (like stubs) as well as <em>pre-programmed expectations</em>. A mock will fail your test if it is not used as expected.</p><h3>When to use mocks?</h3><p>Mocks should only be used for the <em>method under test</em>. In every unit test, there should be one unit under test. If you want to control how your unit is being used and like stating expectations upfront (as opposed to asserting after the fact), use a mock.</p><h3>When to <strong>not</strong> use mocks?</h3><p>Mocks come with built-in expectations that may fail your test. Thus, they enforce implementation details. The rule of thumb is: if you wouldn’t add an assertion for some specific call, don’t mock it. Use a stub instead. In general you should never have more than <strong>one</strong> mock (possibly with several expectations) in a single test.</p><p><a href="#expectations">Expectations</a> implement both the <a href="#spies">spies</a> and <a href="#stubs">stubs</a> APIs.</p><p>To see how mocks look like in Sinon.JS, here’s one of the PubSubJS tests again, this time using a method as callback and using mocks to verify its behavior:</p>
<pre class="codehilite javascript"><code><span class="s2">"test should call all subscribers when exceptions"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">myAPI</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{}</span> <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">mock</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">mock</span><span class="p">(</span><span class="nx">myAPI</span><span class="p">);</span>
    <span class="nx">mock</span><span class="p">.</span><span class="nx">expects</span><span class="p">(</span><span class="s2">"method"</span><span class="p">).</span><span class="nx">once</span><span class="p">().</span><span class="kr">throws</span><span class="p">();</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s2">"message"</span><span class="p">,</span> <span class="nx">myAPI</span><span class="p">.</span><span class="nx">method</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s2">"message"</span><span class="p">,</span> <span class="nx">spy</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">publishSync</span><span class="p">(</span><span class="s2">"message"</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">);</span>

    <span class="nx">mock</span><span class="p">.</span><span class="nx">verify</span><span class="p">();</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">spy</span><span class="p">.</span><span class="nx">calledOnce</span><span class="p">);</span>
<span class="p">}</span>
</code></pre><h3>Mocks API</h3><a name="mocks-api"></a><p></p><dl class="dafuq"><dt><code>var mock = sinon.mock(obj);</code></dt><dd><p>Creates a mock for the provided object. Does not change the object, but returns a mock object to set expectations on the object’s methods.</p></dd><dt><code>var expectation = mock.expects("method");</code></dt><dd><p>Overrides <code>obj.method</code> with a mock function and returns it. See <a href="#expectations-api">expectations</a> below.</p></dd><dt><code>mock.restore();</code></dt><dd><p>Restores all mocked methods.</p></dd><dt><code>mock.verify();</code></dt><dd><p>Verifies all expectations on the mock. If any expectation is not satisfied, an exception is thrown. Also restores the mocked methods.</p></dd></dl><h3>Expectations</h3><a name="expectations-api"></a><p>All the expectation methods return the expectation, meaning you can chain them.
Typical usage:

</p><pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">mock</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">).</span><span class="nx">expects</span><span class="p">(</span><span class="s2">"ajax"</span><span class="p">).</span><span class="nx">atLeast</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nx">atMost</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">.</span><span class="nx">verify</span><span class="p">();</span>
</code></pre><dl class="dafuq"><dt><code>var expectation = sinon.expectation.create([methodName]);</code></dt><dd><p>Creates an expectation without a mock object, basically an anonymous mock function. Method name is optional and is used in exception messages to make them more readable.</p></dd><dt><code>var expectation = sinon.mock();</code></dt><dd><p>The same as the above.</p></dd><dt><code>expectation.atLeast(number);</code></dt><dd><p>Specify the minimum amount of calls expected.</p></dd><dt><code>expectation.atMost(number);</code></dt><dd><p>Specify the maximum amount of calls expected.</p></dd><dt><code>expectation.never();</code></dt><dd><p>Expect the method to never be called.</p></dd><dt><code>expectation.once();</code></dt><dd><p>Expect the method to be called exactly once.</p></dd><dt><code>expectation.twice();</code></dt><dd><p>Expect the method to be called exactly twice.</p></dd><dt><code>expectation.thrice();</code></dt><dd><p>Expect the method to be called exactly thrice.</p></dd><dt><code>expectation.exactly(number);</code></dt><dd><p>Expect the method to be called exactly <code>number</code> times.</p></dd><dt><code>expectation.withArgs(arg1, arg2, ...);</code></dt><dd><p>Expect the method to be called with the provided arguments and possibly others.</p></dd><dt><code>expectation.withExactArgs(arg1, arg2, ...);</code></dt><dd><p>Expect the method to be called with the provided arguments and no others.</p></dd><dt><code>expectation.on(obj);</code></dt><dd><p>Expect the method to be called with <code>obj</code> as <code>this</code>.</p></dd><dt><code>expectation.verify();</code></dt><dd><p>Verifies the expectation and throws an exception if it’s not met.</p></dd></dl></div><div class="section" id="clock"><h2>Fake timers <a class="api" href="#clock-api">API reference</a></h2><p>Fake timers is a synchronous implementation of <code>setTimeout</code> and friends that Sinon.JS can overwrite the global functions with to allow you to more easily test code using them. Fake timers provide a <code>clock</code> object to pass time, which can also be used to control <code>Date</code> objects created through either <code>new Date();</code> or <code>Date.now();</code> (if supported by the browser).</p><p>When faking timers with IE you also need <a href="/releases/sinon-ie-1.12.2.js">sinon-ie-1.12.2</a>, which should be loaded after sinon-1.12.2.js.</p><p>The fake timers can be used completely stand-alone by downloading <a href="/releases/sinon-timers-1.12.2.js">sinon-timers-1.12.2</a> When using the fake timers in IE you also need <a href="/releases/sinon-timers-ie-1.12.2.js">sinon-timers-ie-1.12.2</a>. Load it after the first file.</p>
<pre class="codehilite javascript"><code><span class="p">{</span>
    <span class="nx">setUp</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">clock</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">useFakeTimers</span><span class="p">();</span>
    <span class="p">},</span>

    <span class="nx">tearDown</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nx">restore</span><span class="p">();</span>
    <span class="p">},</span>

    <span class="s2">"test should animate element over 500ms"</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">jQuery</span><span class="p">(</span><span class="s2">"&lt;div&gt;&lt;/div&gt;"</span><span class="p">);</span>
        <span class="nx">el</span><span class="p">.</span><span class="nx">appendTo</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>

        <span class="nx">el</span><span class="p">.</span><span class="nx">animate</span><span class="p">({</span> <span class="nx">height</span><span class="o">:</span> <span class="s2">"200px"</span><span class="p">,</span> <span class="nx">width</span><span class="o">:</span> <span class="s2">"200px"</span> <span class="p">});</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nx">tick</span><span class="p">(</span><span class="mi">510</span><span class="p">);</span>

        <span class="nx">assertEquals</span><span class="p">(</span><span class="s2">"200px"</span><span class="p">,</span> <span class="nx">el</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="s2">"height"</span><span class="p">));</span>
        <span class="nx">assertEquals</span><span class="p">(</span><span class="s2">"200px"</span><span class="p">,</span> <span class="nx">el</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="s2">"width"</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre><h3>Fake timers API</h3><a name="clock-api"></a><p></p><dl class="dafuq"><dt><code>var clock = sinon.useFakeTimers();</code></dt><dd><p>Causes Sinon to replace the global <code>setTimeout</code>, <code>clearTimeout</code>,  <code>setInterval</code>, <code>clearInterval</code> and <code>Date</code> with a custom implementation which  is bound to the returned <code>clock</code> object. Starts the clock at the UNIX epoch (timestamp  of 0)</p></dd><dt><code>var clock = sinon.useFakeTimers(now);</code></dt><dd><p>As above, but rather than starting the clock with a timestamp of 0, start  at the provided timestamp.</p></dd><dt><code>var clock = sinon.useFakeTimers([now, ]prop1, prop2, ...);</code></dt><dd><p>Sets the clock start timestamp and names functions to fake. Possible  functions are setTimeout, clearTimeout, setInterval, clearInterval, and  Date. Can also be called without the timestamp.</p></dd><dt><code>clock.tick(ms);</code></dt><dd><p>Tick the clock ahead <code>ms</code> milliseconds. Causes all timers scheduled within  the affected time range to be called.</p></dd><dt><code>clock.restore();</code></dt><dd><p>Restore the faked methods. Call in e.g. <code>tearDown</code>.</p></dd></dl></div><div class="section" id="server"><h2>Fake <code>XMLHttpRequest</code> <a class="api" href="#server-api">API reference</a></h2><ul class="nav">
  <li><a href="#useFakeXMLHttpRequest">sinon.useFakeXMLHttpRequest</a></li>
  <li><a href="#FakeXMLHttpRequest">FakeXMLHttpRequest</a></li>
  <li><a href="#responses">Simulating responses</a></li>
  <li><a href="#fakeServer">Fake server</a></li>
</ul><p>Provides a fake implementation of <code>XMLHttpRequest</code> and provides several interfaces for manipulating objects created by it. Also fakes the native <code>XMLHttpRequest</code> and <code>ActiveXObject</code> (if available, and only for <code>XMLHTTP</code> progids). Helps with testing requests made with XHR.</p><p>When faking XHR with IE you also need <a href="/releases/sinon-ie-1.12.2.js">sinon-ie-1.12.2</a>, which should be loaded after sinon-1.12.2.js.</p><p>The fake server and XHR can be used completely stand-alone by downloading <a href="/releases/sinon-server-1.12.2.js">sinon-server-1.12.2</a>. When using the fake server in IE you also need <a href="/releases/sinon-ie-1.12.2.js">sinon-ie-1.12.2</a>. Load it after the first file.</p>
<pre class="codehilite javascript"><code><span class="p">{</span>
    <span class="nx">setUp</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">xhr</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">useFakeXMLHttpRequest</span><span class="p">();</span>
        <span class="kd">var</span> <span class="nx">requests</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">requests</span> <span class="o">=</span> <span class="p">[];</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">onCreate</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">requests</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">xhr</span><span class="p">);</span>
        <span class="p">};</span>
    <span class="p">},</span>

    <span class="nx">tearDown</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">restore</span><span class="p">();</span>
    <span class="p">},</span>

    <span class="s2">"test should fetch comments from server"</span> <span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>
        <span class="nx">myLib</span><span class="p">.</span><span class="nx">getCommentsFor</span><span class="p">(</span><span class="s2">"/some/article"</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
        <span class="nx">assertEquals</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">requests</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">requests</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">respond</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"Content-Type"</span><span class="o">:</span> <span class="s2">"application/json"</span> <span class="p">},</span>
                                 <span class="s1">'[{ "id": 12, "comment": "Hey there" }]'</span><span class="p">);</span>
        <span class="nx">assert</span><span class="p">(</span><span class="nx">callback</span><span class="p">.</span><span class="nx">calledWith</span><span class="p">([{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nx">comment</span><span class="o">:</span> <span class="s2">"Hey there"</span> <span class="p">}]));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre><h3><code>sinon.useFakeXMLHttpRequest</code></h3><a name="useFakeXMLHttpRequest"></a><p></p><dl class="dafuq"><dt><code>var xhr = sinon.useFakeXMLHttpRequest();</code></dt><dd><p>Causes Sinon to replace the native <code>XMLHttpRequest</code> object in browsers that  support it with a custom implementation which does not send actual requests.  In browsers that support <code>ActiveXObject</code>, this constructor is replaced, and  fake objects are returned for <code>XMLHTTP</code> progIds. Other progIds, such as  <code>XMLDOM</code> are left untouched.</p></dd><dt><code>xhr.onCreate = function (xhr) {};</code></dt><dd><p>By assigning a function to the <code>onCreate</code> property of the  returned object from <code>useFakeXMLHttpRequest()</code> you can subscribe to newly  created <code>FakeXMLHttpRequest</code> objects. See below for the fake xhr object API.  Using this observer means you can still reach objects created by e.g.  <code>jQuery.ajax</code> (or other abstractions/frameworks).</p></dd><dt><code>xhr.restore();</code></dt><dd><p>Restore original function(s).</p></dd></dl><h3><code>FakeXMLHttpRequest</code></h3><a name="FakeXMLHttpRequest"></a><p></p><dl class="dafuq"><dt><code>String request.url</code></dt><dd><p>The URL set on the request object.</p></dd><dt><code>String request.method</code></dt><dd><p>The request method as a string.</p></dd><dt><code>Object request.requestHeaders</code></dt><dd><p>
      An object of all request headers, i.e.:
    </p>
<pre><code class="js">{
    "Accept": "text/html, */*",
    "Connection": "keep-alive"
}
</code></pre></dd><dt><code>String request.requestBody</code></dt><dd><p>The request body</p></dd><dt><code>int request.status</code></dt><dd><p>The request’s status code. Undefined if the request has not been handled  (see <a href="#respond"><code>respond</code></a> below).</p></dd><dt><code>String request.statusText</code></dt><dd><p>Only populated if the <a href="#respond"><code>respond</code></a> method is called (see below).</p></dd><dt><code>boolean request.async</code></dt><dd><p>Whether or not the request is asynchronous.</p></dd><dt><code>String request.username</code></dt><dd><p>Username, if any.</p></dd><dt><code>String request.password</code></dt><dd><p>Password, if any.</p></dd><dt><code>Document request.responseXML</code></dt><dd><p>When using <a href="#respond"><code>respond</code></a>, this property is populated  with a parsed document if response headers indicate as much (see <a href="http://www.w3.org/TR/XMLHttpRequest/">the  spec</a>).</p></dd><dt><code>String
    request.getResponseHeader(header);</code></dt><dd><p>The value of the given response header, if the request has been responded to (see <a href="#respond"><code>respond</code></a>).</p></dd><dt><code>Object request.getAllResponseHeaders();</code></dt><dd><p>All response headers as an object.</p></dd></dl><h3>Filtered requests</h3><a name="filtered-requests"></a><p>When using Sinon.JS for mockups or partial
integration/functional testing, you might want to fake some requests, while
allowing others to go throught to the backend server. With filtered
`FakeXMLHttpRequest`s (new in Sinon 1.3.0), you can.</p><dl class="dafuq"><dt><code>FakeXMLHttpRequest.useFilters</code></dt><dd><p>Default <code>false</code>. When set to <code>true</code>, Sinon will check added filters if certain requests should be “unfaked”.</p></dd><dt><code>FakeXMLHttpRequest.addFilter(fn)</code></dt><dd><p>Add a filter that will decide whether or not to fake a request. The filter  will be called when <code>xhr.open</code> is called, with the exact same arguments  (<code>method</code>, <code>url</code>, <code>async</code>, <code>username</code>, <code>password</code>). If the filter returns  true, the request will not be faked.</p></dd></dl><h3>Simulating server responses</h3><a name="responses"></a><p></p><dl class="dafuq"><dt><code>request.setResponseHeaders(object);</code></dt><dd><pre><code>Sets response headers (e.g. `{ "Content-Type": "text/html", /* ... */ }`,
  updates the `readyState` property and fires `onreadystatechange`.
</code></pre></dd><dt><code>request.setResponseBody(body);</code></dt><dd><p>Sets the respond body, updates the <code>readyState</code> property and fires  <code>onreadystatechange</code>. Additionally, populates <code>responseXML</code> with a parsed  document if <a href="http://www.w3.org/TR/XMLHttpRequest/">response headers indicate as much</a>.</p></dd><dt><code>var server = sinon.fakeServer.create();</code></dt><dd><p>Creates a new server. This function also calls <code>sinon.useFakeXMLHttpRequest()</code>.</p></dd><dt id="respond"><code>request.respond(status, headers, body);</code></dt><dd><p>Calls the above two methods and sets the <code>status</code> and <code>statusText</code> properties. Status should be a number, the status text is looked up from <code>sinon.FakeXMLHttpRequest.statusCodes</code>.</p></dd><dt id="auto-respond"><code>Boolean request.autoRespond</code></dt><dd><p>When set to <code>true</code>, causes the server to automatically  respond to incoming requests after a timeout. The default timeout is 10ms  but you can control it through the <code>autoRespondAfter</code> property. Note that  this feature is intended to help during mockup development, and is not  suitable for use in tests.</p></dd><dt id="auto-respond-after"><code>Number request.autoRespondAfter</code></dt><dd><p>When <code>autoRespond</code> is <code>true</code>, respond to requests after this number of milliseconds. Default is 10.</p></dd></dl><h3>Fake server</h3><a name="fakeServer"></a><p>High-level API to manipulate `FakeXMLHttpRequest` instances.

<small>For help with handling JSON-P please refer to our [notes below](#json-p)</small>

</p><pre id="server_example" class="sh_javascript timers"><code>{
    setUp: function () {
        this.server = sinon.fakeServer.create();
    },

    tearDown: function () {
        this.server.restore();
    },

    "test should fetch comments from server" : function () {
        this.server.respondWith("GET", "/some/article/comments.json",
            [200, { "Content-Type": "application/json" },
             '[{ "id": 12, "comment": "Hey there" }]']);

        var callback = sinon.spy();
        myLib.getCommentsFor("/some/article", callback);
        this.server.respond();

        sinon.assert.calledWith(callback, [{ id: 12, comment: "Hey there" }]));
    }
}</code></pre><dl class="dafuq"><dt><code>var server = sinon.fakeServer.create();</code></dt><dd><p>Creates a new server. This function also calls <code>sinon.useFakeXMLHttpRequest()</code>.</p></dd><dt><code>var server = sinon.fakeServerWithClock.create();</code></dt><dd><p>Creates a server that also manages fake timers. This is  useful when testing XHR objects created with e.g. jQuery 1.3.x, which uses a  timer to poll the object for completion, rather than the usual  <code>onreadystatechange</code>.</p></dd><dt><code>server.respondWith(response);</code></dt><dd><p><code>response</code> can be on of three things:</p>
<ol>
  <li>A string representing the response body</li>
  <li>An array with status, headers and response body, e.g. <code>[200, { "Content-Type": "text/html", "Content-Length": 2 }, "OK"]</code></li>
  <li>A function.</li>
</ol><p>Default status is 200 and default headers are none. Causes the server to respond to any request not matched by another response with the provided data. The default catch-all response is <code>[404, {}, ""]</code>.</p><p>When the response is a function, it will be passed the request object. You must manually call <a href="#respond">respond</a> on it to complete the request.</p></dd><dt><code>server.respondWith(url, response);</code></dt><dd><p>Responds to all requests to given URL, e.g. <code>/posts/1</code>.</p></dd><dt><code>server.respondWith(method, url, response);</code></dt><dd><p>Responds to all <code>method</code> requests to the given URL with the given response.  <code>method</code> is an HTTP verb.</p></dd><dt><code>server.respondWith(urlRegExp, response);</code></dt><dd><p>URL may be a regular expression, e.g. <code>/\/post\//\d+</code>  If the response is a function, it will be passed any capture groups  from the regular expression along with the XMLHttpRequest object:  </p><pre class="codehilite javascript"><code><span class="nx">server</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span><span class="sr">/\/todo-items\/(\d+)/</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span> <span class="p">{</span>  <span class="nx">xhr</span><span class="p">.</span><span class="nx">respond</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span> <span class="o">?</span><span class="nx">Content</span><span class="o">-</span><span class="nx">Type</span><span class="o">?:</span> <span class="o">?</span><span class="nx">application</span><span class="o">/</span><span class="nx">json</span><span class="o">?</span> <span class="p">},</span> <span class="o">?</span><span class="p">[{</span> <span class="o">?</span><span class="nx">id</span><span class="o">?:</span> <span class="o">?</span> <span class="o">+</span> <span class="nx">id</span> <span class="o">+</span> <span class="o">?</span> <span class="p">}]</span><span class="o">?</span><span class="p">);</span> <span class="p">});</span>
</code></pre></dd><dt><code>server.respondWith(method, urlRegExp, response);</code></dt><dd><p>Responds to all <code>method</code> requests to URLs matching the  regular expression.</p></dd><dt><code>server.respond();</code></dt><dd><p>Causes all queued asynchronous requests to receive a response. If none of  the responses added through <code>respondWith</code> match, the default response is  <code>[404, {}, ""]</code>. Synchronous requests are responded to immediately, so make  sure to call <code>respondWith</code> upfront. If called with arguments, <code>respondWith</code>  will be called with those arguments before responding to requests.</p></dd><dt><code>server.autoRespond = true;</code></dt><dd><p>If set, will call to <code>srv.respondWith</code> automatically after every request.</p></dd><dt><code>server.autoRespondAfter = ms;</code></dt><dd><p>Causes the server to automatically respond to incoming requests after a timeout.</p></dd><dt><code>Boolean `server.fakeHTTPMethods`</code></dt><dd><p>If set to <code>true</code>, server will find <code>_method</code> parameter in POST body and  recognize that as the actual method. Supports a pattern common to Ruby on  Rails applications. For custom HTTP method faking, override  <code>server.getHTTPMethod(request)</code>.</p></dd><dt><code>server.getHTTPMethod(request)</code></dt><dd><p>Used internally to determine the HTTP method used with the provided request.  By default this method simply returns <code>request.method</code>. When  <code>server.fakeHTTPMethods</code> is true, the method will return the value of the  <code>_method</code> parameter if the method is “POST”. This method can be overrided to  provide custom behavior.</p></dd><dt><code>server.restore();</code></dt><dd><p>Restores the native XHR constructor.</p></dd></dl></div><div class="section" id="json-p"><h2>JSON-P <a class="api" href="#json-p-api">API reference</a></h2><p><a name="json-p"></a></p><p>JSON-P doesn’t use Ajax requests, which is what the fake server is concerned with. A JSON-P request actually creates a script element and inserts it into the document. There is no sensible/unobtrusive enough way to fake this automatically. Your best option is to simply stub jQuery in this case:</p>
<pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">,</span> <span class="s2">"ajax"</span><span class="p">);</span>
<span class="nx">sinon</span><span class="p">.</span><span class="nx">assert</span><span class="p">.</span><span class="nx">calledOnce</span><span class="p">(</span><span class="nx">jQuery</span><span class="p">.</span><span class="nx">ajax</span><span class="p">);</span>
</code></pre><p>Potentially we could have had the fake server detect jQuery and fake any calls to jQuery.ajax when JSON-P is used, but that felt like a compromise in the focus of the Sinon project compared to simply documenting the above work-around.</p></div><div class="section" id="assertions"><h2>Assertions <a class="api" href="#assertions-api">API reference</a></h2><p>Sinon.JS ships with a set of assertions that mirror most behavior verification methods and properties on spies and stubs. The advantage of using the assertions is that failed expectations on stubs and spies can be expressed directly as assertion failures with detailed and helpful error messages.</p><p>To make sure assertions integrate nicely with your test framework, you should customize either <code>sinon.assert.fail</code> or <code>sinon.assert.failException</code> and look into <a href="#assert-expose"><code>sinon.assert.expose</code></a> and <a href="#assert-pass"><code>sinon.assert.pass</code></a>.</p><p>The assertions can be used with either spies or stubs.</p>
<pre class="codehilite javascript"><code><span class="s2">"test should call subscribers with message as first argument"</span> <span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">"an example message"</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">spy</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">publishSync</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="s2">"some payload"</span><span class="p">);</span>

    <span class="nx">sinon</span><span class="p">.</span><span class="nx">assert</span><span class="p">.</span><span class="nx">calledOnce</span><span class="p">(</span><span class="nx">spy</span><span class="p">);</span>
    <span class="nx">sinon</span><span class="p">.</span><span class="nx">assert</span><span class="p">.</span><span class="nx">calledWith</span><span class="p">(</span><span class="nx">spy</span><span class="p">,</span> <span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre><h3>Assertions API</h3><a name="assertions-api"></a><p></p><dl class="dafuq"><dt><code>sinon.assert.fail(message)</code></dt><dd><p>Every assertion fails by calling this method. By default it throws an error  of type <code>sinon.assert.failException</code>. If your testing framework looks for  assertion errors by checking for a specific exception, you can simply  override the kind of exception thrown. If that does not fit with your  testing framework of choice, override the <code>fail</code> method to do the right  thing.</p></dd><dt><code>sinon.assert.failException</code></dt><dd><p>Defaults to <code>"AssertError"</code>.</p></dd><dt id="assert-pass"><code>sinon.assert.pass(assertion)</code></dt><dd><p>Called every time an assertion passes. Default implementation does nothing.</p></dd><dt><code>sinon.assert.notCalled(spy)</code></dt><dd><p>Passes if spy was never called.</p></dd><dt><code>sinon.assert.called(spy)</code></dt><dd><p>Passes if spy was called at least once.</p></dd><dt><code>sinon.assert.calledOnce(spy)</code></dt><dd><p>Passes if spy was called once and only once.</p></dd><dt><code>sinon.assert.calledTwice()</code></dt><dd><p>Passes if spy was called exactly twice.</p></dd><dt><code>sinon.assert.calledThrice()</code></dt><dd><p>Passes if spy was called exactly three times.</p></dd><dt><code>sinon.assert.callCount(spy, num)</code></dt><dd><p>Passes if the spy was called exactly <code>num</code> times.</p></dd><dt><code>sinon.assert.callOrder(spy1, spy2, ...)</code></dt><dd><p>Passes if the provided spies where called in the specified order.</p></dd><dt><code>sinon.assert.calledOn(spy, obj)</code></dt><dd><p>Passes if the spy was ever called with <code>obj</code> as its <code>this</code> value.</p></dd><dt><code>sinon.assert.alwaysCalledOn(spy, obj)</code></dt><dd><p>Passes if the spy was always called with <code>obj</code> as its <code>this</code> value.</p></dd><dt><code>sinon.assert.calledWith(spy, arg1, arg2, ...)</code></dt><dd><p>Passes if the spy was called with the provided arguments.</p></dd><dt><code>sinon.assert.alwaysCalledWith(spy, arg1, arg2, ...)</code></dt><dd><p>Passes if the spy was always called with the provided arguments.</p></dd><dt><code>sinon.assert.neverCalledWith(spy, arg1, arg2, ...)</code></dt><dd><p>Passes if the spy was never called with the provided arguments.</p></dd><dt><code>sinon.assert.calledWithExactly(spy, arg1, arg2, ...)</code></dt><dd><p>Passes if the spy was called with the provided arguments and no others.</p></dd><dt><code>sinon.assert.alwaysCalledWithExactly(spy, arg1, arg2, ...)</code></dt><dd><p>Passes if the spy was always called with the provided arguments and no others.</p></dd><dt><code>sinon.assert.calledWithMatch(spy, arg1, arg2, ...)</code></dt><dd><p>Passes if the spy was called with matching arguments. This behaves  the same as <code>sinon.assert.calledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd><dt><code>sinon.assert.alwaysCalledWithMatch(spy, arg1, arg2, ...)</code></dt><dd><p>Passes if the spy was always called with matching arguments. This behaves  the same as <code>sinon.assert.alwaysCalledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd><dt><code>sinon.assert.neverCalledWithMatch(spy, arg1, arg2, ...)</code></dt><dd><p>Passes if the spy was never called with matching arguments. This behaves  the same as <code>sinon.assert.neverCalledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.</p></dd><dt><code>sinon.assert.threw(spy, exception)</code></dt><dd><p>Passes if the spy threw the given exception. The exception can be a string  denoting its type, or an actual object. If only one argument is provided,  the assertion passes if the spy ever threw any exception.</p></dd><dt><code>sinon.assert.alwaysThrew(spy, exception)</code></dt><dd><p>Like above, only required for all calls to the spy.</p></dd><dt id="assert-expose"><code>sinon.assert.expose(object, options)</code></dt><dd><p>Exposes assertions into another object, to better integrate with the test  framework. For instance, JsTestDriver uses global assertions, and to make  Sinon.JS assertions appear alongside them, you can do.</p><pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">assert</span><span class="p">.</span><span class="nx">expose</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</code></pre><p>This will give you <code>assertCalled(spy)</code>,<code>assertCallOrder(spy1, spy2, ...)</code> and so on.</p><p>The method accepts an optional options object with two options.  <strong>prefix</strong> is a prefix to give assertions. By default it is  “assert”, so <code>sinon.assert.called</code> becomes <code>target.assertCalled</code>. By  passing a blank string, the exposed method will be <code>target.called</code>. The  second option, <strong>includeFail</strong> is true by default, and copies  over the <code>fail</code> and <code>failException</code> properties.</p></dd></dl></div><div class="section" id="matchers"><h2>Matchers <a class="api" href="#matchers-api">API reference</a></h2><ul class="nav">
  <li><a href="#sinon-match-api">Matcher API</a></li>
  <li><a href="#sinon-match-andor">Combining matchers</a></li>
  <li><a href="#sinon-match-custom">Custom matchers</a></li>
</ul><p>Matchers can be passed as arguments to <code>spy.calledWith</code>, <code>spy.returned</code> and the corresponding <code>sinon.assert</code> functions as well as <code>spy.withArgs</code>. Matchers allow to be either more fuzzy or more specific about the expected value.</p>
<pre class="codehilite javascript"><code><span class="s2">"test should assert fuzzy"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">book</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">pages</span><span class="o">:</span> <span class="mi">42</span><span class="p">,</span>
        <span class="nx">author</span><span class="o">:</span> <span class="s2">"cjno"</span>
    <span class="p">};</span>
    <span class="kd">var</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">spy</span><span class="p">();</span>

    <span class="nx">spy</span><span class="p">(</span><span class="nx">book</span><span class="p">);</span>

    <span class="nx">sinon</span><span class="p">.</span><span class="nx">assert</span><span class="p">.</span><span class="nx">calledWith</span><span class="p">(</span><span class="nx">spy</span><span class="p">,</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">({</span> <span class="nx">author</span><span class="o">:</span> <span class="s2">"cjno"</span> <span class="p">}));</span>
    <span class="nx">sinon</span><span class="p">.</span><span class="nx">assert</span><span class="p">.</span><span class="nx">calledWith</span><span class="p">(</span><span class="nx">spy</span><span class="p">,</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s2">"pages"</span><span class="p">,</span> <span class="mi">42</span><span class="p">));</span>
<span class="p">}</span>
</code></pre>
<pre class="codehilite javascript"><code><span class="s2">"test should stub method differently based on argument types"</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">stub</span><span class="p">();</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">.</span><span class="nx">string</span><span class="p">).</span><span class="nx">returns</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">withArgs</span><span class="p">(</span><span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">.</span><span class="nx">number</span><span class="p">).</span><span class="kr">throws</span><span class="p">(</span><span class="s2">"TypeError"</span><span class="p">);</span>

    <span class="nx">callback</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">);</span> <span class="c1">// Returns true</span>
    <span class="nx">callback</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">// Throws TypeError</span>
<span class="p">}</span>
</code></pre><h3>Matchers API</h3><a name="sinon-match-api"></a><p></p><dl class="dafuq"><dt><code>sinon.match(number)</code></dt><dd><p>Requires the value to be == to the given number.</p></dd><dt><code>sinon.match(string)</code></dt><dd><p>Requires the value to be a string and have the expectation as a substring.</p></dd><dt><code>sinon.match(regexp)</code></dt><dd><p>Requires the value to be a string and match the given regular expression.</p></dd><dt><code>sinon.match(object)</code></dt><dd><p>Requires the value to be not null or undefined and have at least the same properties as <code>expectation</code>. This supports nested matchers.</p></dd><dt><code>sinon.match(function)</code></dt><dd><p>See <a href="#sinon-match-custom">custom matchers</a>.</p></dd><dt><code>sinon.match.any</code></dt><dd><p>Matches anything.</p></dd><dt><code>sinon.match.defined</code></dt><dd><p>Requires the value to be defined.</p></dd><dt><code>sinon.match.truthy</code></dt><dd><p>Requires the value to be truthy.</p></dd><dt><code>sinon.match.falsy</code></dt><dd><p>Requires the value to be falsy.</p></dd><dt><code>sinon.match.bool</code></dt><dd><p>Requires the value to be a boolean.</p></dd><dt><code>sinon.match.number</code></dt><dd><p>Requires the value to be a number.</p></dd><dt><code>sinon.match.string</code></dt><dd><p>Requires the value to be a string.</p></dd><dt><code>sinon.match.object</code></dt><dd><p>Requires the value to be an object.</p></dd><dt><code>sinon.match.func</code></dt><dd><p>Requires the value to be a function.</p></dd><dt><code>sinon.match.array</code></dt><dd><p>Requires the value to be an array.</p></dd><dt><code>sinon.match.regexp</code></dt><dd><p>Requires the value to be a regular expression.</p></dd><dt><code>sinon.match.date</code></dt><dd><p>Requires the value to be a date object.</p></dd><dt><code>sinon.match.same(ref)</code></dt><dd><p>Requires the value to strictly equal <code>ref</code>.</p></dd><dt><code>sinon.match.typeOf(type)</code></dt><dd><p>Requires the value to be of the given type, where <code>type</code> can be one of  <code>"undefined"</code>,  <code>"null"</code>,  <code>"boolean"</code>,  <code>"number"</code>,  <code>"string"</code>,  <code>"object"</code>,  <code>"function"</code>,  <code>"array"</code>,  <code>"regexp"</code> or  <code>"date"</code>.</p></dd><dt><code>sinon.match.instanceOf(type)</code></dt><dd><p>Requires the value to be an instance of the given type.</p></dd><dt><code>sinon.match.has(property[, expectation])</code></dt><dd><p>Requires the value to define the given property. The property might be inherited via the prototype chain. If the optional expectation is given, the value of the property is deeply compared with the expectation. The expectation can be another matcher.</p></dd><dt><code>sinon.match.hasOwn(property[, expectation])</code></dt><dd><p>Same as <code>sinon.match.has</code> but the property must be defined by the value itself. Inherited properties are ignored.</p></dd></dl><h3>Combining matchers</h3><a name="sinon-match-andor"></a><p>All matchers implement `and` and `or`. This allows to
logically combine mutliple matchers. The result is a new matchers that requires
both (and) or one of the matchers (or) to return true.

</p><pre class="codehilite javascript"><code><span class="kd">var</span> <span class="nx">stringOrNumber</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">.</span><span class="nx">string</span><span class="p">.</span><span class="nx">or</span><span class="p">(</span><span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">.</span><span class="nx">number</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">bookWithPages</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">.</span><span class="nx">instanceOf</span><span class="p">(</span><span class="nx">Book</span><span class="p">).</span><span class="nx">and</span><span class="p">(</span><span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s2">"pages"</span><span class="p">));</span>
</code></pre><dl class="dafuq"></dl><h3>Custom matchers</h3><a name="sinon-match-custom"></a><p>Custom matchers are created with the `sinon.match` factory
which takes a test function and an optional message. The test function takes a
value as the only argument, returns `true` if the value matches the expectation
and `false` otherwise. The message string is used to generate the error message
in case the value does not match the expectation.

</p><pre class="codehilite javascript"><code><span class="kd">var</span> <span class="nx">trueIsh</span> <span class="o">=</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!!</span><span class="nx">value</span><span class="p">;</span>
<span class="p">},</span> <span class="s2">"trueIsh"</span><span class="p">);</span>
</code></pre><dl class="dafuq"></dl></div><div class="section" id="sandbox"><h2>Sandboxes <a class="api" href="#sandbox-api">API reference</a></h2><ul class="nav">
  <li><a href="#sinon-sandbox">sinon.sandbox</a></li>
  <li><a href="#sinon-test">sinon.test</a></li>
  <li><a href="#sinon-testCase">sinon.testCase</a></li>
</ul><p>Sandboxes simplify working with fakes that need to be restored and/or verified. If you’re using fake timers, fake XHR, or you are stubbing/spying on globally accessible properties you should use a sandbox to ease cleanup. By default the spy, stub and mock properties of the sandbox is bound to whatever object the function is run on, so if you don’t want to manually <code>restore()</code>, you have to use <code>this.spy()</code> instead of <code>sinon.spy()</code> (and stub, mock).</p>
<pre class="codehilite javascript"><code><span class="s2">"test using sinon.test sandbox"</span><span class="o">:</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">myAPI</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{}</span> <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">mock</span><span class="p">(</span><span class="nx">myAPI</span><span class="p">).</span><span class="nx">expects</span><span class="p">(</span><span class="s2">"method"</span><span class="p">).</span><span class="nx">once</span><span class="p">();</span>

    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s2">"message"</span><span class="p">,</span> <span class="nx">myAPI</span><span class="p">.</span><span class="nx">method</span><span class="p">);</span>
    <span class="nx">PubSub</span><span class="p">.</span><span class="nx">publishSync</span><span class="p">(</span><span class="s2">"message"</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">);</span>
<span class="p">})</span>
</code></pre><h3>Sandbox API</h3><a name="sinon-sandbox"></a><p></p><dl class="dafuq"><dt><code>var sandbox = sinon.sandbox.create();</code></dt><dd><p>Creates a sandbox object</p></dd><dt><code>var sandbox = sinon.sandbox.create(config);</code></dt><dd><p>
  The `sinon.sandbox.create(config)` method is mostly an
  integration feature, and as an end-user of Sinon.JS you will
  probably not need it.
</p>
<p>
  Creates a pre-configured sandbox object. The configuration can instruct
  the sandbox to include fake timers, fake server, and how to interact with
  these. The default configuration looks like:
</p>
<pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">defaultConfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">injectInto</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">properties</span><span class="o">:</span> <span class="p">[</span><span class="s2">"spy"</span><span class="p">,</span> <span class="s2">"stub"</span><span class="p">,</span> <span class="s2">"mock"</span><span class="p">,</span> <span class="s2">"clock"</span><span class="p">,</span> <span class="s2">"server"</span><span class="p">,</span> <span class="s2">"requests"</span><span class="p">],</span>
    <span class="nx">useFakeTimers</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">useFakeServer</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<dl>
  <dt>injectInto</dt>
  <dd>
    The sandbox's methods can be injected into another object for
    convenience. The `injectInto` configuration option can name an object to
    add properties to. Usually, this is set by `sinon.test` such that it is
    the `this` value in a given test function.
  </dd>
  <dt>properties</dt>
  <dd>
    What properties to inject. Note that simply naming "server" here is not
    sufficient to have a `server` property show up in the target object, you
    also have to set `useFakeServer` to true.
  </dd>
  <dt>useFakeTimers</dt>
  <dd>
    If `true`, the sandbox will have a `clock` property. Can also be an
    array of timer properties to fake.
  </dd>
  <dt>useFakeServer</dt>
  <dd>
    <p>
      If `true`, `server` and `requests` properties are added to the
      sandbox. Can also be an object to use for fake server. The default one
      is `sinon.fakeServer`, but if you're using jQuery 1.3.x or some other
      library that does not set the XHR's `onreadystatechange` handler, you
      might want to do:
    </p>
    <pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">useFakeServer</span><span class="o">:</span> <span class="nx">sinon</span><span class="p">.</span><span class="nx">fakeServerWithClock</span>
<span class="p">};</span>
</code></pre>
  </dd>
</dl></dd><dt><code>sandbox.spy();</code></dt><dd><p>Works exactly like <code>sinon.spy</code>, only also adds the returned spy to the  internal collection of fakes for easy restoring through <code>sandbox.restore()</code>.</p></dd><dt><code>sandbox.stub();</code></dt><dd><p>Works almost exactly like <code>sinon.stub</code>, only also adds the returned stub to  the internal collection of fakes for easy restoring through  <code>sandbox.restore()</code>. The sandbox <code>stub</code> method can also be used to stub any  kind of property. This is useful if you need to override an object’s  property for the duration of a test, and have it restored when the test  completes.</p></dd><dt><code>sandbox.mock();</code></dt><dd><p>Works exactly like <code>sinon.mock</code>, only also adds the returned mock to the  internal collection of fakes for easy restoring through <code>sandbox.restore()</code>.</p></dd><dt><code>sandbox.useFakeTimers();</code></dt><dd><p>Fakes timers and binds the <code>clock</code> object to the sandbox such that it too is  restored when calling <code>sandbox.restore()</code>. Access through <code>sandbox.clock</code>.</p></dd><dt><code>sandbox.useFakeXMLHttpRequest();</code></dt><dd><p>Fakes XHR and binds the resulting object to the sandbox such that it too is  restored when calling <code>sandbox.restore()</code>. Access requests through  <code>sandbox.requests</code>.</p></dd><dt><code>sandbox.useFakeServer();</code></dt><dd><p>Fakes XHR and binds a server object to the sandbox such that it too is  restored when calling <code>sandbox.restore()</code>. Access requests through  <code>sandbox.requests</code> and server through <code>sandbox.server</code>.</p></dd><dt><code>sandbox.restore();</code></dt><dd><p>Restores all fakes created through sandbox.</p></dd></dl><h3>Test methods</h3><a name="sinon-test"></a><p>Wrapping test methods in `sinon.test` allows Sinon.JS to automatically create
and manage sandboxes for you. The function's behavior can be configured through
`sinon.config`.</p><dl class="dafuq"><dt><code>var wrappedFn = sinon.test(fn);</code></dt><dd><p>The <code>wrappedFn</code> function works exactly like the original one in all respect - in addition a sandbox object is created and automatically restored when the function finishes a call. By default the spy, stub and mock properties of the sandbox is bound to whatever object the function is run on, so you can do <code>this.spy()</code> (and stub, mock) and it works exactly like <code>sandbox.spy()</code> (and stub, mock), except you don’t need to manually <code>restore()</code>.</p>
<pre class="codehilite javascript"><code><span class="p">{</span>
    <span class="nx">injectIntoThis</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">injectInto</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">properties</span><span class="o">:</span> <span class="p">[</span><span class="s2">"spy"</span><span class="p">,</span> <span class="s2">"stub"</span><span class="p">,</span> <span class="s2">"mock"</span><span class="p">,</span> <span class="s2">"clock"</span><span class="p">,</span> <span class="s2">"server"</span><span class="p">,</span> <span class="s2">"requests"</span><span class="p">],</span>
    <span class="nx">useFakeTimers</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">useFakeServer</span><span class="o">:</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre><p>Simply set <code>sinon.config</code> to override any or all of these, e.g.:</p>
<pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">useFakeTimers</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">useFakeServer</span><span class="o">:</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre><p>In this case, defaults are used for the non-existent properties. Additionally, sandboxes and tests will not have automatic access to the fake timers and fake server when using this configuration.</p></dd></dl><h3>sinon.config</h3><a name="sinon-config"></a><p>The configuration controls how Sinon binds properties when using `sinon.test`.
The default configuration looks like:</p><dl class="dafuq"><dt><code>Boolean injectIntoThis</code></dt><dd><p>Causes properties to be injected into the <code>this</code> object of the test  function. Default <code>true</code>.</p></dd><dt><code>Object injectInto</code></dt><dd><p>Object to bind properties to. If this is <code>null</code> (default) and  <code>injectIntoThis</code> is <code>false</code> (not default), the properties are passed as  arguments to the test function instead.</p></dd><dt><code>Array properties</code></dt><dd><p>Properties to expose. Default is all:  <code>["spy", "stub", "mock", "clock", "server", "requests"]</code>. However, the last  three properties are only bound if the following two configuration options  are <code>true</code> (which is the default).</p></dd><dt><code>Boolean useFakeTimers</code></dt><dd><p>Causes timers to be faked and allows <code>clock</code> property to be exposed. Default is <code>true</code>.</p></dd><dt><code>Boolean useFakeServer</code></dt><dd><p>Causes fake XHR and server to be created and allows <code>server</code> and <code>requests</code>  properties to be exposed. Default is <code>true</code>.</p></dd></dl><h3>Test cases</h3><a name="sinon-testCase"></a><p>If you need the behavior of `sinon.test` for more than one
test method in a test case, you can use `sinon.testCase`, which behaves exactly
like wrapping each test in `sinon.test` with one exception: `setUp` and
`tearDown` can share fakes.</p><dl class="dafuq"><dt><code>var obj = sinon.testCase({});</code></dt><dd></dd></dl></div><div class="section" id="utils"><h2>Sinon.JS utilities <a class="api" href="#utils-api">API reference</a></h2><p>Sinon.JS has a few utilities used internally in lib/sinon.js.  Unless the method in question is documented here, it should not be  considered part of the public API, and thus is subject to change.</p><h3>Utils API</h3><a name="utils-api"></a><p></p><dl class="dafuq"><dt><code>sinon.createStubInstance(constructor)</code></dt><dd><p>Creates a new object with the given function as the protoype and stubs all implemented functions. The given constructor function is not invoked. See also the <a href="#stubs">stub API</a>.</p></dd><dt><code>sinon.format(object)</code></dt><dd><p>Formats an object for pretty printing in error messages. Sinon &lt; 1.3.0 defaulted to coercing objects to strings. As of 1.3.0, Sinon uses <a href="https://busterjs.org/docs/buster-format/">buster-format</a> by default, or Node’s <a href="http://nodejs.org/docs/v0.6.6/api/util.html">util</a> module. Feel free to override this method with your own implementation if you prefer different visualization of e.g. objects. The method should return a string.</p></dd><dt><code>sinon.log(string)</code></dt><dd><p>Logs internal errors, helpful for debugging. By default this property is a noop function, set it to something that prints warnings in your environment for more help, e.g. (if you are using JsTestDriver): </p><pre class="codehilite javascript"><code><span class="nx">sinon</span><span class="p">.</span><span class="nx">log</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>  <span class="nx">jstestdriver</span><span class="p">.</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="p">};</span>
</code></pre></dd></dl><code></code></div><code></code></div><code></code><div class="aside"><code></code><p><code>Sinon uses <a href="http://semver.org/">Semantic versioning</a>.</code></p><code></code><p><code>Copyright 2010 - 2014, <a href="http://cjohansen.no/">Christian Johansen</a>. Released under the <a href="http://www.opensource.org/licenses/bsd-license.php">BSD license</a>.</code></p><code></code></div><code><script src="/261e08e3134b/scripts/sinon-web.js"></script><script src="/releases/sinon.js"></script><script src="/releases/sinon-ie.js"></script></code></body></html><code></code>